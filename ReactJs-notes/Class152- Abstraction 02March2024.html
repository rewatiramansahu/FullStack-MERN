
===================== Class152- Abstraction 02March2024 ==================

Abstraction

TypeScript OOP
- Interface
- Classes
    a) Static
    b) Non Static

                         Access Modifiers
- Access modifier is used to configure access restriction for properties and methods in classes.
        a) public
        b) private
        c) protected

Syntax:
     class Name
     {
        public  PropertyName;
        private MethodName():void {
        }
    }

- public
    * It is accessible within class or outside class.
    * It is accessible with instance of class or with instance of derived class.
    * It is public in access.
    * It is the default access modifier for members in class.

- private
    * It is accessible within class.
    * It is not accessible outside class.
    * You can't access with class obj or a derived class object.
   
- protected
    * It is accessible within class.
    * It is accessible outside class but only within the derived class and only by using      
      derived cass object.

Ex:
class Product
{
     public Name = "Samsung TV";
     private Price = 45000.33;
     protected Stock = true;
     public Print():void
     {
          console.log(`Name=${this.Name}\nPrice=${this.Price}\nStock=${this.Stock}`);
     }
}
class Derived extends Product
{
     public Print():void {
          let obj = new Derived();
          obj.Name;            // public
          obj.Stock;          //protected
     }
}
let obj = new Derived();
obj.Name;                     // public


Access Witin Class                Access Outside Class       Access with Derived Obj
--------------------------------------------------------------------------------------------------------------------
public                        public                  public
private                        protected                      protected
protected                        [not outside derived]      [inside derived class]


- Inheritance is same as in JavaScript
    a) Aggregation
    b) Inheritance
- Typescript class can implement contracts.
- Contract defines rules for creating a class and configuring its members.
- A class can implement multiple contracts.

Syntax:
    interface  IProduct
    {
    }
    class Product implements IProduct
    {
    }

Ex:
interface IProduct
{
     Name:string;
     Price:number;
     Qty:number;
     Total():number;
     Print?():void;
}
interface ICategory
{
     CategoryName:string;
}
export class Product implements IProduct, ICategory
{
     Name = "TV";
     Price = 45000.33;
     Qty = 2;
     CategoryName = "Electronics";
     Total(){
       return this.Qty * this.Price
     }
     Print(){
          console.log(`Name=${this.Name}\nPrice=${this.Price}\nQty=${this.Qty}\nTotal=${this.Total()}\nCategory=${this.CategoryName}`);
     }
}
let obj = new Product();
obj.Print();

                          Templates in OOP
- A template comprises of features already implemented and some are left for customization and implementation.
- A template hides the structure and provides only implementation, which is known as "Abstraction".
- It is mostly used in "Rollouts".
- Rollout is a process of developing template for client requirements, so that it can be customized and implemented by client.
- Templates in OOP are created as  "Abstract Classes".
- An abstract class comprisess of members which are implemented with functionality and some not-implemented.
- The members need to be implemented are marked as "abstract".
- If a class is having at least one abstract member, then class is also marked as "abstract".


Ex:
interface IProduct
{
     Name:string;
     Price:number;
     Qty:number;
     Total():number;
     Print():void;
}
abstract class ProductTemplate implements IProduct
{
     public Name:string = "";
     public Price:number = 0;
     public Qty:number = 0;
     abstract Total():number;
     abstract Print():void;
}
class ProductComponent extends ProductTemplate
{
     Name = "Samsung TV";
     Price = 50000.44;
     Qty = 2;
     Total() {
          return this.Qty * this.Price;
     }
     Print(){
          console.log(`Name=${this.Name}\nPrice=${this.Price}\nTotal=${this.Total()}`);
     }
}
let obj = new ProductComponent();
obj.Print();